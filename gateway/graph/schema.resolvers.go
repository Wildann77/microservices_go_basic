package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/microservices-go/gateway/graph/generated"
	"github.com/microservices-go/gateway/graph/model"
)

// Mutation resolvers
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	url := fmt.Sprintf("%s/api/v1/users/register", r.userServiceURL)
	resp, err := r.makeRequest(ctx, "POST", url, input, "")
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		var errResp map[string]interface{}
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("registration failed: %v", errResp)
	}

	var result struct {
		Data *model.AuthResponse `json:"data"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	url := fmt.Sprintf("%s/api/v1/users/login", r.userServiceURL)
	resp, err := r.makeRequest(ctx, "POST", url, input, "")
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		var errResp map[string]interface{}
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("login failed: %v", errResp)
	}

	var result struct {
		Data *model.AuthResponse `json:"data"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, firstName *string, lastName *string, isActive *bool) (*model.User, error) {
	body := map[string]interface{}{}
	if firstName != nil {
		body["first_name"] = *firstName
	}
	if lastName != nil {
		body["last_name"] = *lastName
	}
	if isActive != nil {
		body["is_active"] = *isActive
	}

	url := fmt.Sprintf("%s/api/v1/users/%s", r.userServiceURL, id)
	resp, err := r.makeRequest(ctx, "PUT", url, body, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to update user")
	}

	var result struct {
		Data *model.User `json:"data"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	url := fmt.Sprintf("%s/api/v1/users/%s", r.userServiceURL, id)
	resp, err := r.makeRequest(ctx, "DELETE", url, nil, r.getAuthHeader(ctx))
	if err != nil {
		return false, err
	}
	defer resp.Body.Close()

	return resp.StatusCode == http.StatusNoContent, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*model.Order, error) {
	// Get current user
	me, err := r.Query().Me(ctx)
	if err != nil {
		return nil, err
	}

	// Build request body
	items := make([]map[string]interface{}, len(input.Items))
	for i, item := range input.Items {
		items[i] = map[string]interface{}{
			"product_id":   item.ProductID,
			"product_name": item.ProductName,
			"quantity":     item.Quantity,
			"unit_price":   item.UnitPrice,
		}
	}

	body := map[string]interface{}{
		"user_id":          me.ID,
		"currency":         input.Currency,
		"shipping_address": input.ShippingAddress,
		"notes":            input.Notes,
		"items":            items,
	}

	url := fmt.Sprintf("%s/api/v1/orders", r.orderServiceURL)
	resp, err := r.makeRequest(ctx, "POST", url, body, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		var errResp map[string]interface{}
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("failed to create order: %v", errResp)
	}

	var result struct {
		Data *model.Order `json:"data"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, id string, status string) (*model.Order, error) {
	body := map[string]interface{}{"status": status}

	url := fmt.Sprintf("%s/api/v1/orders/%s/status", r.orderServiceURL, id)
	resp, err := r.makeRequest(ctx, "PATCH", url, body, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to update order status")
	}

	var result struct {
		Data *model.Order `json:"data"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

// CreatePayment is the resolver for the createPayment field.
func (r *mutationResolver) CreatePayment(ctx context.Context, input model.CreatePaymentInput) (*model.Payment, error) {
	// Get current user
	me, err := r.Query().Me(ctx)
	if err != nil {
		return nil, err
	}

	body := map[string]interface{}{
		"order_id":    input.OrderID,
		"user_id":     me.ID,
		"amount":      input.Amount,
		"currency":    input.Currency,
		"method":      input.Method,
		"description": input.Description,
	}

	url := fmt.Sprintf("%s/api/v1/payments", r.paymentServiceURL)
	resp, err := r.makeRequest(ctx, "POST", url, body, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		var errResp map[string]interface{}
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("failed to create payment: %v", errResp)
	}

	var result struct {
		Data *model.Payment `json:"data"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

// ProcessPayment is the resolver for the processPayment field.
func (r *mutationResolver) ProcessPayment(ctx context.Context, id string) (*model.Payment, error) {
	url := fmt.Sprintf("%s/api/v1/payments/%s/process", r.paymentServiceURL, id)
	resp, err := r.makeRequest(ctx, "POST", url, nil, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		var errResp map[string]interface{}
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("failed to process payment: %v", errResp)
	}

	var result struct {
		Data *model.Payment `json:"data"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

// RefundPayment is the resolver for the refundPayment field.
func (r *mutationResolver) RefundPayment(ctx context.Context, id string, amount *float64, reason *string) (*model.Payment, error) {
	body := map[string]interface{}{}
	if amount != nil {
		body["amount"] = *amount
	}
	if reason != nil {
		body["reason"] = *reason
	}

	url := fmt.Sprintf("%s/api/v1/payments/%s/refund", r.paymentServiceURL, id)
	resp, err := r.makeRequest(ctx, "POST", url, body, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		var errResp map[string]interface{}
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("failed to refund payment: %v", errResp)
	}

	var result struct {
		Data *model.Payment `json:"data"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

// Order resolvers
func (r *orderResolver) User(ctx context.Context, obj *model.Order) (*model.User, error) {
	loaders := GetLoaders(ctx)
	return loaders.UserLoader.Load(ctx, obj.UserID)
}

// ShippingAddress is the resolver for the shippingAddress field.
func (r *orderResolver) ShippingAddress(ctx context.Context, obj *model.Order) (string, error) {
	return obj.ShippingAddress, nil
}

// Payment is the resolver for the payment field.
func (r *orderResolver) Payment(ctx context.Context, obj *model.Order) (*model.Payment, error) {
	loaders := GetLoaders(ctx)
	return loaders.PaymentLoader.LoadByOrder(ctx, obj.ID)
}

// Payment resolvers
func (r *paymentResolver) Order(ctx context.Context, obj *model.Payment) (*model.Order, error) {
	loaders := GetLoaders(ctx)
	return loaders.OrderLoader.LoadByID(ctx, obj.OrderID)
}

// User is the resolver for the user field.
func (r *paymentResolver) User(ctx context.Context, obj *model.Payment) (*model.User, error) {
	loaders := GetLoaders(ctx)
	return loaders.UserLoader.Load(ctx, obj.UserID)
}

// Query resolvers
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	url := fmt.Sprintf("%s/api/v1/users/me", r.userServiceURL)
	resp, err := r.makeRequest(ctx, "GET", url, nil, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to get current user")
	}

	var result struct {
		Data *model.User `json:"data"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Data, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	loaders := GetLoaders(ctx)
	return loaders.UserLoader.Load(ctx, id)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) (*model.UserConnection, error) {
	l := 10
	o := 0
	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	url := fmt.Sprintf("%s/api/v1/users?limit=%d&offset=%d", r.userServiceURL, l, o)
	resp, err := r.makeRequest(ctx, "GET", url, nil, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data []*model.User          `json:"data"`
		Meta map[string]interface{} `json:"meta"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	total := 0
	if t, ok := result.Meta["total"].(float64); ok {
		total = int(t)
	}

	return &model.UserConnection{
		Data: result.Data,
		PageInfo: model.PageInfo{
			Total:   total,
			Limit:   l,
			Offset:  o,
			HasMore: o+l < total,
		},
	}, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*model.Order, error) {
	loaders := GetLoaders(ctx)
	return loaders.OrderLoader.LoadByID(ctx, id)
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context, limit *int, offset *int) (*model.OrderConnection, error) {
	l := 10
	o := 0
	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	url := fmt.Sprintf("%s/api/v1/orders?limit=%d&offset=%d", r.orderServiceURL, l, o)
	resp, err := r.makeRequest(ctx, "GET", url, nil, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data []*model.Order         `json:"data"`
		Meta map[string]interface{} `json:"meta"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	total := 0
	if t, ok := result.Meta["total"].(float64); ok {
		total = int(t)
	}

	return &model.OrderConnection{
		Data: result.Data,
		PageInfo: model.PageInfo{
			Total:   total,
			Limit:   l,
			Offset:  o,
			HasMore: o+l < total,
		},
	}, nil
}

// MyOrders is the resolver for the myOrders field.
func (r *queryResolver) MyOrders(ctx context.Context, limit *int, offset *int) (*model.OrderConnection, error) {
	l := 10
	o := 0
	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	url := fmt.Sprintf("%s/api/v1/orders/my-orders?limit=%d&offset=%d", r.orderServiceURL, l, o)
	resp, err := r.makeRequest(ctx, "GET", url, nil, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data []*model.Order         `json:"data"`
		Meta map[string]interface{} `json:"meta"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	total := 0
	if t, ok := result.Meta["total"].(float64); ok {
		total = int(t)
	}

	return &model.OrderConnection{
		Data: result.Data,
		PageInfo: model.PageInfo{
			Total:   total,
			Limit:   l,
			Offset:  o,
			HasMore: o+l < total,
		},
	}, nil
}

// Payment is the resolver for the payment field.
func (r *queryResolver) Payment(ctx context.Context, id string) (*model.Payment, error) {
	loaders := GetLoaders(ctx)
	return loaders.PaymentLoader.LoadByID(ctx, id)
}

// PaymentByOrder is the resolver for the paymentByOrder field.
func (r *queryResolver) PaymentByOrder(ctx context.Context, orderID string) (*model.Payment, error) {
	loaders := GetLoaders(ctx)
	return loaders.PaymentLoader.LoadByOrder(ctx, orderID)
}

// Payments is the resolver for the payments field.
func (r *queryResolver) Payments(ctx context.Context, limit *int, offset *int) (*model.PaymentConnection, error) {
	l := 10
	o := 0
	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	url := fmt.Sprintf("%s/api/v1/payments?limit=%d&offset=%d", r.paymentServiceURL, l, o)
	resp, err := r.makeRequest(ctx, "GET", url, nil, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data []*model.Payment       `json:"data"`
		Meta map[string]interface{} `json:"meta"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	total := 0
	if t, ok := result.Meta["total"].(float64); ok {
		total = int(t)
	}

	return &model.PaymentConnection{
		Data: result.Data,
		PageInfo: model.PageInfo{
			Total:   total,
			Limit:   l,
			Offset:  o,
			HasMore: o+l < total,
		},
	}, nil
}

// MyPayments is the resolver for the myPayments field.
func (r *queryResolver) MyPayments(ctx context.Context, limit *int, offset *int) (*model.PaymentConnection, error) {
	l := 10
	o := 0
	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	url := fmt.Sprintf("%s/api/v1/payments/my-payments?limit=%d&offset=%d", r.paymentServiceURL, l, o)
	resp, err := r.makeRequest(ctx, "GET", url, nil, r.getAuthHeader(ctx))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data []*model.Payment       `json:"data"`
		Meta map[string]interface{} `json:"meta"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	total := 0
	if t, ok := result.Meta["total"].(float64); ok {
		total = int(t)
	}

	return &model.PaymentConnection{
		Data: result.Data,
		PageInfo: model.PageInfo{
			Total:   total,
			Limit:   l,
			Offset:  o,
			HasMore: o+l < total,
		},
	}, nil
}

// User resolvers
func (r *userResolver) Orders(ctx context.Context, obj *model.User, limit *int, offset *int) ([]*model.Order, error) {
	l := 10
	o := 0
	if limit != nil {
		l = *limit
	}
	if offset != nil {
		o = *offset
	}

	loaders := GetLoaders(ctx)
	return loaders.OrderLoader.LoadByUser(ctx, obj.ID, l, o)
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Order returns generated.OrderResolver implementation.
func (r *Resolver) Order() generated.OrderResolver { return &orderResolver{r} }

// Payment returns generated.PaymentResolver implementation.
func (r *Resolver) Payment() generated.PaymentResolver { return &paymentResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type orderResolver struct{ *Resolver }
type paymentResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
